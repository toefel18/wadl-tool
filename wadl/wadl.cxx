// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "wadl.hxx"

namespace wadl
{
  // resource_type_list
  //

  resource_type_list::
  resource_type_list ()
  : ::xsd::cxx::tree::list< ::xml_schema::uri, char > (this)
  {
  }

  resource_type_list::
  resource_type_list (size_type n, const ::xml_schema::uri& x)
  : ::xsd::cxx::tree::list< ::xml_schema::uri, char > (n, x, this)
  {
  }

  resource_type_list::
  resource_type_list (const resource_type_list& o,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::uri, char > (o, f, this)
  {
  }

  // Method
  //

  Method::
  Method (const char* s)
  : ::xml_schema::string (s)
  {
  }

  Method::
  Method (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  Method::
  Method (const Method& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // HTTPMethods
  // 

  HTTPMethods::
  HTTPMethods (value v)
  : ::xml_schema::nmtoken (_xsd_HTTPMethods_literals_[v])
  {
  }

  HTTPMethods::
  HTTPMethods (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  HTTPMethods::
  HTTPMethods (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  HTTPMethods::
  HTTPMethods (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  HTTPMethods::
  HTTPMethods (const HTTPMethods& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  HTTPMethods& HTTPMethods::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_HTTPMethods_literals_[v]);

    return *this;
  }


  // uriList
  //

  uriList::
  uriList ()
  : ::xsd::cxx::tree::list< ::xml_schema::uri, char > (this)
  {
  }

  uriList::
  uriList (size_type n, const ::xml_schema::uri& x)
  : ::xsd::cxx::tree::list< ::xml_schema::uri, char > (n, x, this)
  {
  }

  uriList::
  uriList (const uriList& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::uri, char > (o, f, this)
  {
  }

  // statusCodeList
  //

  statusCodeList::
  statusCodeList ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (this)
  {
  }

  statusCodeList::
  statusCodeList (size_type n, const ::xml_schema::unsigned_int& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (n, x, this)
  {
  }

  statusCodeList::
  statusCodeList (const statusCodeList& o,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (o, f, this)
  {
  }

  // ParamStyle
  // 

  ParamStyle::
  ParamStyle (value v)
  : ::xml_schema::string (_xsd_ParamStyle_literals_[v])
  {
  }

  ParamStyle::
  ParamStyle (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ParamStyle::
  ParamStyle (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ParamStyle::
  ParamStyle (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ParamStyle::
  ParamStyle (const ParamStyle& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ParamStyle& ParamStyle::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ParamStyle_literals_[v]);

    return *this;
  }


  // application
  // 

  const application::doc_sequence& application::
  getDoc () const
  {
    return this->doc_;
  }

  application::doc_sequence& application::
  getDoc ()
  {
    return this->doc_;
  }

  void application::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const application::grammars_optional& application::
  getGrammars () const
  {
    return this->grammars_;
  }

  application::grammars_optional& application::
  getGrammars ()
  {
    return this->grammars_;
  }

  void application::
  setGrammars (const grammars_type& x)
  {
    this->grammars_.set (x);
  }

  void application::
  setGrammars (const grammars_optional& x)
  {
    this->grammars_ = x;
  }

  void application::
  setGrammars (::std::unique_ptr< grammars_type > x)
  {
    this->grammars_.set (std::move (x));
  }

  const application::resources_sequence& application::
  getResources () const
  {
    return this->resources_;
  }

  application::resources_sequence& application::
  getResources ()
  {
    return this->resources_;
  }

  void application::
  setResources (const resources_sequence& s)
  {
    this->resources_ = s;
  }

  const application::resource_type_sequence& application::
  getResource_type () const
  {
    return this->resource_type_;
  }

  application::resource_type_sequence& application::
  getResource_type ()
  {
    return this->resource_type_;
  }

  void application::
  setResource_type (const resource_type_sequence& s)
  {
    this->resource_type_ = s;
  }

  const application::method_sequence& application::
  getMethod () const
  {
    return this->method_;
  }

  application::method_sequence& application::
  getMethod ()
  {
    return this->method_;
  }

  void application::
  setMethod (const method_sequence& s)
  {
    this->method_ = s;
  }

  const application::representation_sequence& application::
  getRepresentation () const
  {
    return this->representation_;
  }

  application::representation_sequence& application::
  getRepresentation ()
  {
    return this->representation_;
  }

  void application::
  setRepresentation (const representation_sequence& s)
  {
    this->representation_ = s;
  }

  const application::param_sequence& application::
  getParam () const
  {
    return this->param_;
  }

  application::param_sequence& application::
  getParam ()
  {
    return this->param_;
  }

  void application::
  setParam (const param_sequence& s)
  {
    this->param_ = s;
  }


  // doc
  // 

  const doc::title_optional& doc::
  getTitle () const
  {
    return this->title_;
  }

  doc::title_optional& doc::
  getTitle ()
  {
    return this->title_;
  }

  void doc::
  setTitle (const title_type& x)
  {
    this->title_.set (x);
  }

  void doc::
  setTitle (const title_optional& x)
  {
    this->title_ = x;
  }

  void doc::
  setTitle (::std::unique_ptr< title_type > x)
  {
    this->title_.set (std::move (x));
  }

  const doc::lang_optional& doc::
  getLang () const
  {
    return this->lang_;
  }

  doc::lang_optional& doc::
  getLang ()
  {
    return this->lang_;
  }

  void doc::
  setLang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void doc::
  setLang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void doc::
  setLang (::std::unique_ptr< lang_type > x)
  {
    this->lang_.set (std::move (x));
  }


  // grammars
  // 

  const grammars::doc_sequence& grammars::
  getDoc () const
  {
    return this->doc_;
  }

  grammars::doc_sequence& grammars::
  getDoc ()
  {
    return this->doc_;
  }

  void grammars::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const grammars::include_sequence& grammars::
  getInclude () const
  {
    return this->include_;
  }

  grammars::include_sequence& grammars::
  getInclude ()
  {
    return this->include_;
  }

  void grammars::
  setInclude (const include_sequence& s)
  {
    this->include_ = s;
  }


  // resources
  // 

  const resources::doc_sequence& resources::
  getDoc () const
  {
    return this->doc_;
  }

  resources::doc_sequence& resources::
  getDoc ()
  {
    return this->doc_;
  }

  void resources::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const resources::resource_sequence& resources::
  getResource () const
  {
    return this->resource_;
  }

  resources::resource_sequence& resources::
  getResource ()
  {
    return this->resource_;
  }

  void resources::
  setResource (const resource_sequence& s)
  {
    this->resource_ = s;
  }

  const resources::base_optional& resources::
  getBase () const
  {
    return this->base_;
  }

  resources::base_optional& resources::
  getBase ()
  {
    return this->base_;
  }

  void resources::
  setBase (const base_type& x)
  {
    this->base_.set (x);
  }

  void resources::
  setBase (const base_optional& x)
  {
    this->base_ = x;
  }

  void resources::
  setBase (::std::unique_ptr< base_type > x)
  {
    this->base_.set (std::move (x));
  }


  // resource
  // 

  const resource::doc_sequence& resource::
  getDoc () const
  {
    return this->doc_;
  }

  resource::doc_sequence& resource::
  getDoc ()
  {
    return this->doc_;
  }

  void resource::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const resource::param_sequence& resource::
  getParam () const
  {
    return this->param_;
  }

  resource::param_sequence& resource::
  getParam ()
  {
    return this->param_;
  }

  void resource::
  setParam (const param_sequence& s)
  {
    this->param_ = s;
  }

  const resource::method_sequence& resource::
  getMethod () const
  {
    return this->method_;
  }

  resource::method_sequence& resource::
  getMethod ()
  {
    return this->method_;
  }

  void resource::
  setMethod (const method_sequence& s)
  {
    this->method_ = s;
  }

  const resource::resource1_sequence& resource::
  getResource1 () const
  {
    return this->resource1_;
  }

  resource::resource1_sequence& resource::
  getResource1 ()
  {
    return this->resource1_;
  }

  void resource::
  setResource1 (const resource1_sequence& s)
  {
    this->resource1_ = s;
  }

  const resource::id_optional& resource::
  getId () const
  {
    return this->id_;
  }

  resource::id_optional& resource::
  getId ()
  {
    return this->id_;
  }

  void resource::
  setId (const id_type& x)
  {
    this->id_.set (x);
  }

  void resource::
  setId (const id_optional& x)
  {
    this->id_ = x;
  }

  void resource::
  setId (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const resource::type_optional& resource::
  getType () const
  {
    return this->type_;
  }

  resource::type_optional& resource::
  getType ()
  {
    return this->type_;
  }

  void resource::
  setType (const type_type& x)
  {
    this->type_.set (x);
  }

  void resource::
  setType (const type_optional& x)
  {
    this->type_ = x;
  }

  void resource::
  setType (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const resource::queryType_type& resource::
  getQueryType () const
  {
    return this->queryType_.get ();
  }

  resource::queryType_type& resource::
  getQueryType ()
  {
    return this->queryType_.get ();
  }

  void resource::
  setQueryType (const queryType_type& x)
  {
    this->queryType_.set (x);
  }

  void resource::
  setQueryType (::std::unique_ptr< queryType_type > x)
  {
    this->queryType_.set (std::move (x));
  }

  const resource::queryType_type& resource::
  getQueryTypeDefaultValue ()
  {
    return queryType_default_value_;
  }

  const resource::path_optional& resource::
  getPath () const
  {
    return this->path_;
  }

  resource::path_optional& resource::
  getPath ()
  {
    return this->path_;
  }

  void resource::
  setPath (const path_type& x)
  {
    this->path_.set (x);
  }

  void resource::
  setPath (const path_optional& x)
  {
    this->path_ = x;
  }

  void resource::
  setPath (::std::unique_ptr< path_type > x)
  {
    this->path_.set (std::move (x));
  }


  // resource_type
  // 

  const resource_type::doc_sequence& resource_type::
  getDoc () const
  {
    return this->doc_;
  }

  resource_type::doc_sequence& resource_type::
  getDoc ()
  {
    return this->doc_;
  }

  void resource_type::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const resource_type::param_sequence& resource_type::
  getParam () const
  {
    return this->param_;
  }

  resource_type::param_sequence& resource_type::
  getParam ()
  {
    return this->param_;
  }

  void resource_type::
  setParam (const param_sequence& s)
  {
    this->param_ = s;
  }

  const resource_type::method_sequence& resource_type::
  getMethod () const
  {
    return this->method_;
  }

  resource_type::method_sequence& resource_type::
  getMethod ()
  {
    return this->method_;
  }

  void resource_type::
  setMethod (const method_sequence& s)
  {
    this->method_ = s;
  }

  const resource_type::resource_sequence& resource_type::
  getResource () const
  {
    return this->resource_;
  }

  resource_type::resource_sequence& resource_type::
  getResource ()
  {
    return this->resource_;
  }

  void resource_type::
  setResource (const resource_sequence& s)
  {
    this->resource_ = s;
  }

  const resource_type::id_optional& resource_type::
  getId () const
  {
    return this->id_;
  }

  resource_type::id_optional& resource_type::
  getId ()
  {
    return this->id_;
  }

  void resource_type::
  setId (const id_type& x)
  {
    this->id_.set (x);
  }

  void resource_type::
  setId (const id_optional& x)
  {
    this->id_ = x;
  }

  void resource_type::
  setId (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // method
  // 

  const method::doc_sequence& method::
  getDoc () const
  {
    return this->doc_;
  }

  method::doc_sequence& method::
  getDoc ()
  {
    return this->doc_;
  }

  void method::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const method::request_optional& method::
  getRequest () const
  {
    return this->request_;
  }

  method::request_optional& method::
  getRequest ()
  {
    return this->request_;
  }

  void method::
  setRequest (const request_type& x)
  {
    this->request_.set (x);
  }

  void method::
  setRequest (const request_optional& x)
  {
    this->request_ = x;
  }

  void method::
  setRequest (::std::unique_ptr< request_type > x)
  {
    this->request_.set (std::move (x));
  }

  const method::response_sequence& method::
  getResponse () const
  {
    return this->response_;
  }

  method::response_sequence& method::
  getResponse ()
  {
    return this->response_;
  }

  void method::
  setResponse (const response_sequence& s)
  {
    this->response_ = s;
  }

  const method::id_optional& method::
  getId () const
  {
    return this->id_;
  }

  method::id_optional& method::
  getId ()
  {
    return this->id_;
  }

  void method::
  setId (const id_type& x)
  {
    this->id_.set (x);
  }

  void method::
  setId (const id_optional& x)
  {
    this->id_ = x;
  }

  void method::
  setId (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const method::name_optional& method::
  getName () const
  {
    return this->name_;
  }

  method::name_optional& method::
  getName ()
  {
    return this->name_;
  }

  void method::
  setName (const name_type& x)
  {
    this->name_.set (x);
  }

  void method::
  setName (const name_optional& x)
  {
    this->name_ = x;
  }

  void method::
  setName (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const method::href_optional& method::
  getHref () const
  {
    return this->href_;
  }

  method::href_optional& method::
  getHref ()
  {
    return this->href_;
  }

  void method::
  setHref (const href_type& x)
  {
    this->href_.set (x);
  }

  void method::
  setHref (const href_optional& x)
  {
    this->href_ = x;
  }

  void method::
  setHref (::std::unique_ptr< href_type > x)
  {
    this->href_.set (std::move (x));
  }


  // include
  // 

  const include::doc_sequence& include::
  getDoc () const
  {
    return this->doc_;
  }

  include::doc_sequence& include::
  getDoc ()
  {
    return this->doc_;
  }

  void include::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const include::href_optional& include::
  getHref () const
  {
    return this->href_;
  }

  include::href_optional& include::
  getHref ()
  {
    return this->href_;
  }

  void include::
  setHref (const href_type& x)
  {
    this->href_.set (x);
  }

  void include::
  setHref (const href_optional& x)
  {
    this->href_ = x;
  }

  void include::
  setHref (::std::unique_ptr< href_type > x)
  {
    this->href_.set (std::move (x));
  }


  // request
  // 

  const request::doc_sequence& request::
  getDoc () const
  {
    return this->doc_;
  }

  request::doc_sequence& request::
  getDoc ()
  {
    return this->doc_;
  }

  void request::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const request::param_sequence& request::
  getParam () const
  {
    return this->param_;
  }

  request::param_sequence& request::
  getParam ()
  {
    return this->param_;
  }

  void request::
  setParam (const param_sequence& s)
  {
    this->param_ = s;
  }

  const request::representation_sequence& request::
  getRepresentation () const
  {
    return this->representation_;
  }

  request::representation_sequence& request::
  getRepresentation ()
  {
    return this->representation_;
  }

  void request::
  setRepresentation (const representation_sequence& s)
  {
    this->representation_ = s;
  }


  // response
  // 

  const response::doc_sequence& response::
  getDoc () const
  {
    return this->doc_;
  }

  response::doc_sequence& response::
  getDoc ()
  {
    return this->doc_;
  }

  void response::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const response::param_sequence& response::
  getParam () const
  {
    return this->param_;
  }

  response::param_sequence& response::
  getParam ()
  {
    return this->param_;
  }

  void response::
  setParam (const param_sequence& s)
  {
    this->param_ = s;
  }

  const response::representation_sequence& response::
  getRepresentation () const
  {
    return this->representation_;
  }

  response::representation_sequence& response::
  getRepresentation ()
  {
    return this->representation_;
  }

  void response::
  setRepresentation (const representation_sequence& s)
  {
    this->representation_ = s;
  }

  const response::status_optional& response::
  getStatus () const
  {
    return this->status_;
  }

  response::status_optional& response::
  getStatus ()
  {
    return this->status_;
  }

  void response::
  setStatus (const status_type& x)
  {
    this->status_.set (x);
  }

  void response::
  setStatus (const status_optional& x)
  {
    this->status_ = x;
  }

  void response::
  setStatus (::std::unique_ptr< status_type > x)
  {
    this->status_.set (std::move (x));
  }


  // representation
  // 

  const representation::doc_sequence& representation::
  getDoc () const
  {
    return this->doc_;
  }

  representation::doc_sequence& representation::
  getDoc ()
  {
    return this->doc_;
  }

  void representation::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const representation::param_sequence& representation::
  getParam () const
  {
    return this->param_;
  }

  representation::param_sequence& representation::
  getParam ()
  {
    return this->param_;
  }

  void representation::
  setParam (const param_sequence& s)
  {
    this->param_ = s;
  }

  const representation::id_optional& representation::
  getId () const
  {
    return this->id_;
  }

  representation::id_optional& representation::
  getId ()
  {
    return this->id_;
  }

  void representation::
  setId (const id_type& x)
  {
    this->id_.set (x);
  }

  void representation::
  setId (const id_optional& x)
  {
    this->id_ = x;
  }

  void representation::
  setId (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const representation::element_optional& representation::
  getElement () const
  {
    return this->element_;
  }

  representation::element_optional& representation::
  getElement ()
  {
    return this->element_;
  }

  void representation::
  setElement (const element_type& x)
  {
    this->element_.set (x);
  }

  void representation::
  setElement (const element_optional& x)
  {
    this->element_ = x;
  }

  void representation::
  setElement (::std::unique_ptr< element_type > x)
  {
    this->element_.set (std::move (x));
  }

  const representation::mediaType_optional& representation::
  getMediaType () const
  {
    return this->mediaType_;
  }

  representation::mediaType_optional& representation::
  getMediaType ()
  {
    return this->mediaType_;
  }

  void representation::
  setMediaType (const mediaType_type& x)
  {
    this->mediaType_.set (x);
  }

  void representation::
  setMediaType (const mediaType_optional& x)
  {
    this->mediaType_ = x;
  }

  void representation::
  setMediaType (::std::unique_ptr< mediaType_type > x)
  {
    this->mediaType_.set (std::move (x));
  }

  const representation::href_optional& representation::
  getHref () const
  {
    return this->href_;
  }

  representation::href_optional& representation::
  getHref ()
  {
    return this->href_;
  }

  void representation::
  setHref (const href_type& x)
  {
    this->href_.set (x);
  }

  void representation::
  setHref (const href_optional& x)
  {
    this->href_ = x;
  }

  void representation::
  setHref (::std::unique_ptr< href_type > x)
  {
    this->href_.set (std::move (x));
  }

  const representation::profile_optional& representation::
  getProfile () const
  {
    return this->profile_;
  }

  representation::profile_optional& representation::
  getProfile ()
  {
    return this->profile_;
  }

  void representation::
  setProfile (const profile_type& x)
  {
    this->profile_.set (x);
  }

  void representation::
  setProfile (const profile_optional& x)
  {
    this->profile_ = x;
  }

  void representation::
  setProfile (::std::unique_ptr< profile_type > x)
  {
    this->profile_.set (std::move (x));
  }


  // param
  // 

  const param::doc_sequence& param::
  getDoc () const
  {
    return this->doc_;
  }

  param::doc_sequence& param::
  getDoc ()
  {
    return this->doc_;
  }

  void param::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const param::option_sequence& param::
  getOption () const
  {
    return this->option_;
  }

  param::option_sequence& param::
  getOption ()
  {
    return this->option_;
  }

  void param::
  setOption (const option_sequence& s)
  {
    this->option_ = s;
  }

  const param::link_optional& param::
  getLink () const
  {
    return this->link_;
  }

  param::link_optional& param::
  getLink ()
  {
    return this->link_;
  }

  void param::
  setLink (const link_type& x)
  {
    this->link_.set (x);
  }

  void param::
  setLink (const link_optional& x)
  {
    this->link_ = x;
  }

  void param::
  setLink (::std::unique_ptr< link_type > x)
  {
    this->link_.set (std::move (x));
  }

  const param::href_optional& param::
  getHref () const
  {
    return this->href_;
  }

  param::href_optional& param::
  getHref ()
  {
    return this->href_;
  }

  void param::
  setHref (const href_type& x)
  {
    this->href_.set (x);
  }

  void param::
  setHref (const href_optional& x)
  {
    this->href_ = x;
  }

  void param::
  setHref (::std::unique_ptr< href_type > x)
  {
    this->href_.set (std::move (x));
  }

  const param::name_optional& param::
  getName () const
  {
    return this->name_;
  }

  param::name_optional& param::
  getName ()
  {
    return this->name_;
  }

  void param::
  setName (const name_type& x)
  {
    this->name_.set (x);
  }

  void param::
  setName (const name_optional& x)
  {
    this->name_ = x;
  }

  void param::
  setName (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const param::style_optional& param::
  getStyle () const
  {
    return this->style_;
  }

  param::style_optional& param::
  getStyle ()
  {
    return this->style_;
  }

  void param::
  setStyle (const style_type& x)
  {
    this->style_.set (x);
  }

  void param::
  setStyle (const style_optional& x)
  {
    this->style_ = x;
  }

  void param::
  setStyle (::std::unique_ptr< style_type > x)
  {
    this->style_.set (std::move (x));
  }

  const param::id_optional& param::
  getId () const
  {
    return this->id_;
  }

  param::id_optional& param::
  getId ()
  {
    return this->id_;
  }

  void param::
  setId (const id_type& x)
  {
    this->id_.set (x);
  }

  void param::
  setId (const id_optional& x)
  {
    this->id_ = x;
  }

  void param::
  setId (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const param::type_type& param::
  getType () const
  {
    return this->type_.get ();
  }

  param::type_type& param::
  getType ()
  {
    return this->type_.get ();
  }

  void param::
  setType (const type_type& x)
  {
    this->type_.set (x);
  }

  void param::
  setType (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const param::type_type& param::
  getTypeDefaultValue ()
  {
    return type_default_value_;
  }

  const param::default_optional& param::
  getDefault () const
  {
    return this->default__;
  }

  param::default_optional& param::
  getDefault ()
  {
    return this->default__;
  }

  void param::
  setDefault (const default_type& x)
  {
    this->default__.set (x);
  }

  void param::
  setDefault (const default_optional& x)
  {
    this->default__ = x;
  }

  void param::
  setDefault (::std::unique_ptr< default_type > x)
  {
    this->default__.set (std::move (x));
  }

  const param::required_type& param::
  getRequired () const
  {
    return this->required_.get ();
  }

  param::required_type& param::
  getRequired ()
  {
    return this->required_.get ();
  }

  void param::
  setRequired (const required_type& x)
  {
    this->required_.set (x);
  }

  param::required_type param::
  getRequiredDefaultValue ()
  {
    return required_type (false);
  }

  const param::repeating_type& param::
  getRepeating () const
  {
    return this->repeating_.get ();
  }

  param::repeating_type& param::
  getRepeating ()
  {
    return this->repeating_.get ();
  }

  void param::
  setRepeating (const repeating_type& x)
  {
    this->repeating_.set (x);
  }

  param::repeating_type param::
  getRepeatingDefaultValue ()
  {
    return repeating_type (false);
  }

  const param::fixed_optional& param::
  getFixed () const
  {
    return this->fixed_;
  }

  param::fixed_optional& param::
  getFixed ()
  {
    return this->fixed_;
  }

  void param::
  setFixed (const fixed_type& x)
  {
    this->fixed_.set (x);
  }

  void param::
  setFixed (const fixed_optional& x)
  {
    this->fixed_ = x;
  }

  void param::
  setFixed (::std::unique_ptr< fixed_type > x)
  {
    this->fixed_.set (std::move (x));
  }

  const param::path_optional& param::
  getPath () const
  {
    return this->path_;
  }

  param::path_optional& param::
  getPath ()
  {
    return this->path_;
  }

  void param::
  setPath (const path_type& x)
  {
    this->path_.set (x);
  }

  void param::
  setPath (const path_optional& x)
  {
    this->path_ = x;
  }

  void param::
  setPath (::std::unique_ptr< path_type > x)
  {
    this->path_.set (std::move (x));
  }


  // option
  // 

  const option::doc_sequence& option::
  getDoc () const
  {
    return this->doc_;
  }

  option::doc_sequence& option::
  getDoc ()
  {
    return this->doc_;
  }

  void option::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const option::value_type& option::
  getValue () const
  {
    return this->value_.get ();
  }

  option::value_type& option::
  getValue ()
  {
    return this->value_.get ();
  }

  void option::
  setValue (const value_type& x)
  {
    this->value_.set (x);
  }

  void option::
  setValue (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const option::mediaType_optional& option::
  getMediaType () const
  {
    return this->mediaType_;
  }

  option::mediaType_optional& option::
  getMediaType ()
  {
    return this->mediaType_;
  }

  void option::
  setMediaType (const mediaType_type& x)
  {
    this->mediaType_.set (x);
  }

  void option::
  setMediaType (const mediaType_optional& x)
  {
    this->mediaType_ = x;
  }

  void option::
  setMediaType (::std::unique_ptr< mediaType_type > x)
  {
    this->mediaType_.set (std::move (x));
  }


  // link
  // 

  const link::doc_sequence& link::
  getDoc () const
  {
    return this->doc_;
  }

  link::doc_sequence& link::
  getDoc ()
  {
    return this->doc_;
  }

  void link::
  setDoc (const doc_sequence& s)
  {
    this->doc_ = s;
  }

  const link::resource_type_optional& link::
  getResource_type () const
  {
    return this->resource_type_;
  }

  link::resource_type_optional& link::
  getResource_type ()
  {
    return this->resource_type_;
  }

  void link::
  setResource_type (const resource_type_type& x)
  {
    this->resource_type_.set (x);
  }

  void link::
  setResource_type (const resource_type_optional& x)
  {
    this->resource_type_ = x;
  }

  void link::
  setResource_type (::std::unique_ptr< resource_type_type > x)
  {
    this->resource_type_.set (std::move (x));
  }

  const link::rel_optional& link::
  getRel () const
  {
    return this->rel_;
  }

  link::rel_optional& link::
  getRel ()
  {
    return this->rel_;
  }

  void link::
  setRel (const rel_type& x)
  {
    this->rel_.set (x);
  }

  void link::
  setRel (const rel_optional& x)
  {
    this->rel_ = x;
  }

  void link::
  setRel (::std::unique_ptr< rel_type > x)
  {
    this->rel_.set (std::move (x));
  }

  const link::rev_optional& link::
  getRev () const
  {
    return this->rev_;
  }

  link::rev_optional& link::
  getRev ()
  {
    return this->rev_;
  }

  void link::
  setRev (const rev_type& x)
  {
    this->rev_.set (x);
  }

  void link::
  setRev (const rev_optional& x)
  {
    this->rev_ = x;
  }

  void link::
  setRev (::std::unique_ptr< rev_type > x)
  {
    this->rev_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace wadl
{
  // resource_type_list
  //

  resource_type_list::
  resource_type_list (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::uri, char > (e, f, this)
  {
  }

  resource_type_list::
  resource_type_list (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::uri, char > (a, f, this)
  {
  }

  resource_type_list::
  resource_type_list (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::uri, char > (s, e, f, this)
  {
  }

  resource_type_list* resource_type_list::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class resource_type_list (*this, f, c);
  }

  resource_type_list::
  ~resource_type_list ()
  {
  }

  // Method
  //

  Method::
  Method (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Method::
  Method (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Method::
  Method (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Method* Method::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Method (*this, f, c);
  }

  // HTTPMethods
  //

  HTTPMethods::
  HTTPMethods (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_HTTPMethods_convert ();
  }

  HTTPMethods::
  HTTPMethods (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_HTTPMethods_convert ();
  }

  HTTPMethods::
  HTTPMethods (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_HTTPMethods_convert ();
  }

  HTTPMethods* HTTPMethods::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HTTPMethods (*this, f, c);
  }

  HTTPMethods::value HTTPMethods::
  _xsd_HTTPMethods_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_HTTPMethods_literals_);
    const value* i (::std::lower_bound (
                      _xsd_HTTPMethods_indexes_,
                      _xsd_HTTPMethods_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_HTTPMethods_indexes_ + 5 || _xsd_HTTPMethods_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const HTTPMethods::
  _xsd_HTTPMethods_literals_[5] =
  {
    "GET",
    "POST",
    "PUT",
    "HEAD",
    "DELETE"
  };

  const HTTPMethods::value HTTPMethods::
  _xsd_HTTPMethods_indexes_[5] =
  {
    ::wadl::HTTPMethods::DELETE,
    ::wadl::HTTPMethods::GET,
    ::wadl::HTTPMethods::HEAD,
    ::wadl::HTTPMethods::POST,
    ::wadl::HTTPMethods::PUT
  };

  // uriList
  //

  uriList::
  uriList (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::uri, char > (e, f, this)
  {
  }

  uriList::
  uriList (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::uri, char > (a, f, this)
  {
  }

  uriList::
  uriList (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::uri, char > (s, e, f, this)
  {
  }

  uriList* uriList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class uriList (*this, f, c);
  }

  uriList::
  ~uriList ()
  {
  }

  // statusCodeList
  //

  statusCodeList::
  statusCodeList (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (e, f, this)
  {
  }

  statusCodeList::
  statusCodeList (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (a, f, this)
  {
  }

  statusCodeList::
  statusCodeList (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (s, e, f, this)
  {
  }

  statusCodeList* statusCodeList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class statusCodeList (*this, f, c);
  }

  statusCodeList::
  ~statusCodeList ()
  {
  }

  // ParamStyle
  //

  ParamStyle::
  ParamStyle (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ParamStyle_convert ();
  }

  ParamStyle::
  ParamStyle (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ParamStyle_convert ();
  }

  ParamStyle::
  ParamStyle (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ParamStyle_convert ();
  }

  ParamStyle* ParamStyle::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ParamStyle (*this, f, c);
  }

  ParamStyle::value ParamStyle::
  _xsd_ParamStyle_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ParamStyle_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ParamStyle_indexes_,
                      _xsd_ParamStyle_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_ParamStyle_indexes_ + 5 || _xsd_ParamStyle_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ParamStyle::
  _xsd_ParamStyle_literals_[5] =
  {
    "plain",
    "query",
    "matrix",
    "header",
    "template"
  };

  const ParamStyle::value ParamStyle::
  _xsd_ParamStyle_indexes_[5] =
  {
    ::wadl::ParamStyle::header,
    ::wadl::ParamStyle::matrix,
    ::wadl::ParamStyle::plain,
    ::wadl::ParamStyle::query,
    ::wadl::ParamStyle::template_
  };

  // application
  //

  application::
  application ()
  : ::xml_schema::type (),
    doc_ (this),
    grammars_ (this),
    resources_ (this),
    resource_type_ (this),
    method_ (this),
    representation_ (this),
    param_ (this)
  {
  }

  application::
  application (const application& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    grammars_ (x.grammars_, f, this),
    resources_ (x.resources_, f, this),
    resource_type_ (x.resource_type_, f, this),
    method_ (x.method_, f, this),
    representation_ (x.representation_, f, this),
    param_ (x.param_, f, this)
  {
  }

  application::
  application (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    grammars_ (this),
    resources_ (this),
    resource_type_ (this),
    method_ (this),
    representation_ (this),
    param_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void application::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // grammars
      //
      if (n.name () == "grammars" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< grammars_type > r (
          grammars_traits::create (i, f, this));

        if (!this->grammars_)
        {
          this->grammars_.set (::std::move (r));
          continue;
        }
      }

      // resources
      //
      if (n.name () == "resources" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< resources_type > r (
          resources_traits::create (i, f, this));

        this->resources_.push_back (::std::move (r));
        continue;
      }

      // resource_type
      //
      if (n.name () == "resource_type" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< resource_type_type > r (
          resource_type_traits::create (i, f, this));

        this->resource_type_.push_back (::std::move (r));
        continue;
      }

      // method
      //
      if (n.name () == "method" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< method_type > r (
          method_traits::create (i, f, this));

        this->method_.push_back (::std::move (r));
        continue;
      }

      // representation
      //
      if (n.name () == "representation" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< representation_type > r (
          representation_traits::create (i, f, this));

        this->representation_.push_back (::std::move (r));
        continue;
      }

      // param
      //
      if (n.name () == "param" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< param_type > r (
          param_traits::create (i, f, this));

        this->param_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  application* application::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class application (*this, f, c);
  }

  application& application::
  operator= (const application& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->grammars_ = x.grammars_;
      this->resources_ = x.resources_;
      this->resource_type_ = x.resource_type_;
      this->method_ = x.method_;
      this->representation_ = x.representation_;
      this->param_ = x.param_;
    }

    return *this;
  }

  application::
  ~application ()
  {
  }

  // doc
  //

  doc::
  doc ()
  : ::xml_schema::type (),
    title_ (this),
    lang_ (this)
  {
  }

  doc::
  doc (const doc& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    title_ (x.title_, f, this),
    lang_ (x.lang_, f, this)
  {
  }

  doc::
  doc (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    title_ (this),
    lang_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void doc::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "title" && n.namespace_ ().empty ())
      {
        this->title_.set (title_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }
    }
  }

  doc* doc::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class doc (*this, f, c);
  }

  doc& doc::
  operator= (const doc& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->title_ = x.title_;
      this->lang_ = x.lang_;
    }

    return *this;
  }

  doc::
  ~doc ()
  {
  }

  // grammars
  //

  grammars::
  grammars ()
  : ::xml_schema::type (),
    doc_ (this),
    include_ (this)
  {
  }

  grammars::
  grammars (const grammars& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    include_ (x.include_, f, this)
  {
  }

  grammars::
  grammars (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    include_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void grammars::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // include
      //
      if (n.name () == "include" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< include_type > r (
          include_traits::create (i, f, this));

        this->include_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  grammars* grammars::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class grammars (*this, f, c);
  }

  grammars& grammars::
  operator= (const grammars& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->include_ = x.include_;
    }

    return *this;
  }

  grammars::
  ~grammars ()
  {
  }

  // resources
  //

  resources::
  resources ()
  : ::xml_schema::type (),
    doc_ (this),
    resource_ (this),
    base_ (this)
  {
  }

  resources::
  resources (const resources& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    resource_ (x.resource_, f, this),
    base_ (x.base_, f, this)
  {
  }

  resources::
  resources (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    resource_ (this),
    base_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void resources::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // resource
      //
      if (n.name () == "resource" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< resource_type > r (
          resource_traits::create (i, f, this));

        this->resource_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "base" && n.namespace_ ().empty ())
      {
        this->base_.set (base_traits::create (i, f, this));
        continue;
      }
    }
  }

  resources* resources::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class resources (*this, f, c);
  }

  resources& resources::
  operator= (const resources& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->resource_ = x.resource_;
      this->base_ = x.base_;
    }

    return *this;
  }

  resources::
  ~resources ()
  {
  }

  // resource
  //

  const resource::queryType_type resource::queryType_default_value_ (
    "application/x-www-form-urlencoded");

  resource::
  resource ()
  : ::xml_schema::type (),
    doc_ (this),
    param_ (this),
    method_ (this),
    resource1_ (this),
    id_ (this),
    type_ (this),
    queryType_ (getQueryTypeDefaultValue (), this),
    path_ (this)
  {
  }

  resource::
  resource (const resource& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    param_ (x.param_, f, this),
    method_ (x.method_, f, this),
    resource1_ (x.resource1_, f, this),
    id_ (x.id_, f, this),
    type_ (x.type_, f, this),
    queryType_ (x.queryType_, f, this),
    path_ (x.path_, f, this)
  {
  }

  resource::
  resource (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    param_ (this),
    method_ (this),
    resource1_ (this),
    id_ (this),
    type_ (this),
    queryType_ (this),
    path_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void resource::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // param
      //
      if (n.name () == "param" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< param_type > r (
          param_traits::create (i, f, this));

        this->param_.push_back (::std::move (r));
        continue;
      }

      // method
      //
      if (n.name () == "method" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< method_type > r (
          method_traits::create (i, f, this));

        this->method_.push_back (::std::move (r));
        continue;
      }

      // resource
      //
      if (n.name () == "resource" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< resource1_type > r (
          resource1_traits::create (i, f, this));

        this->resource1_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "queryType" && n.namespace_ ().empty ())
      {
        this->queryType_.set (queryType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "path" && n.namespace_ ().empty ())
      {
        this->path_.set (path_traits::create (i, f, this));
        continue;
      }
    }

    if (!queryType_.present ())
    {
      this->queryType_.set (getQueryTypeDefaultValue ());
    }
  }

  resource* resource::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class resource (*this, f, c);
  }

  resource& resource::
  operator= (const resource& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->param_ = x.param_;
      this->method_ = x.method_;
      this->resource1_ = x.resource1_;
      this->id_ = x.id_;
      this->type_ = x.type_;
      this->queryType_ = x.queryType_;
      this->path_ = x.path_;
    }

    return *this;
  }

  resource::
  ~resource ()
  {
  }

  // resource_type
  //

  resource_type::
  resource_type ()
  : ::xml_schema::type (),
    doc_ (this),
    param_ (this),
    method_ (this),
    resource_ (this),
    id_ (this)
  {
  }

  resource_type::
  resource_type (const resource_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    param_ (x.param_, f, this),
    method_ (x.method_, f, this),
    resource_ (x.resource_, f, this),
    id_ (x.id_, f, this)
  {
  }

  resource_type::
  resource_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    param_ (this),
    method_ (this),
    resource_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void resource_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // param
      //
      if (n.name () == "param" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< param_type > r (
          param_traits::create (i, f, this));

        this->param_.push_back (::std::move (r));
        continue;
      }

      // method
      //
      if (n.name () == "method" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< method_type > r (
          method_traits::create (i, f, this));

        this->method_.push_back (::std::move (r));
        continue;
      }

      // resource
      //
      if (n.name () == "resource" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< resource_type1 > r (
          resource_traits::create (i, f, this));

        this->resource_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  resource_type* resource_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class resource_type (*this, f, c);
  }

  resource_type& resource_type::
  operator= (const resource_type& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->param_ = x.param_;
      this->method_ = x.method_;
      this->resource_ = x.resource_;
      this->id_ = x.id_;
    }

    return *this;
  }

  resource_type::
  ~resource_type ()
  {
  }

  // method
  //

  method::
  method ()
  : ::xml_schema::type (),
    doc_ (this),
    request_ (this),
    response_ (this),
    id_ (this),
    name_ (this),
    href_ (this)
  {
  }

  method::
  method (const method& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    request_ (x.request_, f, this),
    response_ (x.response_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    href_ (x.href_, f, this)
  {
  }

  method::
  method (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    request_ (this),
    response_ (this),
    id_ (this),
    name_ (this),
    href_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void method::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // request
      //
      if (n.name () == "request" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< request_type > r (
          request_traits::create (i, f, this));

        if (!this->request_)
        {
          this->request_.set (::std::move (r));
          continue;
        }
      }

      // response
      //
      if (n.name () == "response" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< response_type > r (
          response_traits::create (i, f, this));

        this->response_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        this->href_.set (href_traits::create (i, f, this));
        continue;
      }
    }
  }

  method* method::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class method (*this, f, c);
  }

  method& method::
  operator= (const method& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->request_ = x.request_;
      this->response_ = x.response_;
      this->id_ = x.id_;
      this->name_ = x.name_;
      this->href_ = x.href_;
    }

    return *this;
  }

  method::
  ~method ()
  {
  }

  // include
  //

  include::
  include ()
  : ::xml_schema::type (),
    doc_ (this),
    href_ (this)
  {
  }

  include::
  include (const include& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    href_ (x.href_, f, this)
  {
  }

  include::
  include (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    href_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void include::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        this->href_.set (href_traits::create (i, f, this));
        continue;
      }
    }
  }

  include* include::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class include (*this, f, c);
  }

  include& include::
  operator= (const include& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->href_ = x.href_;
    }

    return *this;
  }

  include::
  ~include ()
  {
  }

  // request
  //

  request::
  request ()
  : ::xml_schema::type (),
    doc_ (this),
    param_ (this),
    representation_ (this)
  {
  }

  request::
  request (const request& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    param_ (x.param_, f, this),
    representation_ (x.representation_, f, this)
  {
  }

  request::
  request (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    param_ (this),
    representation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void request::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // param
      //
      if (n.name () == "param" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< param_type > r (
          param_traits::create (i, f, this));

        this->param_.push_back (::std::move (r));
        continue;
      }

      // representation
      //
      if (n.name () == "representation" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< representation_type > r (
          representation_traits::create (i, f, this));

        this->representation_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  request* request::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class request (*this, f, c);
  }

  request& request::
  operator= (const request& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->param_ = x.param_;
      this->representation_ = x.representation_;
    }

    return *this;
  }

  request::
  ~request ()
  {
  }

  // response
  //

  response::
  response ()
  : ::xml_schema::type (),
    doc_ (this),
    param_ (this),
    representation_ (this),
    status_ (this)
  {
  }

  response::
  response (const response& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    param_ (x.param_, f, this),
    representation_ (x.representation_, f, this),
    status_ (x.status_, f, this)
  {
  }

  response::
  response (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    param_ (this),
    representation_ (this),
    status_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // param
      //
      if (n.name () == "param" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< param_type > r (
          param_traits::create (i, f, this));

        this->param_.push_back (::std::move (r));
        continue;
      }

      // representation
      //
      if (n.name () == "representation" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< representation_type > r (
          representation_traits::create (i, f, this));

        this->representation_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "status" && n.namespace_ ().empty ())
      {
        this->status_.set (status_traits::create (i, f, this));
        continue;
      }
    }
  }

  response* response::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class response (*this, f, c);
  }

  response& response::
  operator= (const response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->param_ = x.param_;
      this->representation_ = x.representation_;
      this->status_ = x.status_;
    }

    return *this;
  }

  response::
  ~response ()
  {
  }

  // representation
  //

  representation::
  representation ()
  : ::xml_schema::type (),
    doc_ (this),
    param_ (this),
    id_ (this),
    element_ (this),
    mediaType_ (this),
    href_ (this),
    profile_ (this)
  {
  }

  representation::
  representation (const representation& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    param_ (x.param_, f, this),
    id_ (x.id_, f, this),
    element_ (x.element_, f, this),
    mediaType_ (x.mediaType_, f, this),
    href_ (x.href_, f, this),
    profile_ (x.profile_, f, this)
  {
  }

  representation::
  representation (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    param_ (this),
    id_ (this),
    element_ (this),
    mediaType_ (this),
    href_ (this),
    profile_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void representation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // param
      //
      if (n.name () == "param" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< param_type > r (
          param_traits::create (i, f, this));

        this->param_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "element" && n.namespace_ ().empty ())
      {
        this->element_.set (element_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mediaType" && n.namespace_ ().empty ())
      {
        this->mediaType_.set (mediaType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        this->href_.set (href_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "profile" && n.namespace_ ().empty ())
      {
        this->profile_.set (profile_traits::create (i, f, this));
        continue;
      }
    }
  }

  representation* representation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class representation (*this, f, c);
  }

  representation& representation::
  operator= (const representation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->param_ = x.param_;
      this->id_ = x.id_;
      this->element_ = x.element_;
      this->mediaType_ = x.mediaType_;
      this->href_ = x.href_;
      this->profile_ = x.profile_;
    }

    return *this;
  }

  representation::
  ~representation ()
  {
  }

  // param
  //

  const param::type_type param::type_default_value_ (
    ::xml_schema::qname ("http://www.w3.org/2001/XMLSchema", "string"));

  param::
  param ()
  : ::xml_schema::type (),
    doc_ (this),
    option_ (this),
    link_ (this),
    href_ (this),
    name_ (this),
    style_ (this),
    id_ (this),
    type_ (getTypeDefaultValue (), this),
    default__ (this),
    required_ (getRequiredDefaultValue (), this),
    repeating_ (getRepeatingDefaultValue (), this),
    fixed_ (this),
    path_ (this)
  {
  }

  param::
  param (const param& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    option_ (x.option_, f, this),
    link_ (x.link_, f, this),
    href_ (x.href_, f, this),
    name_ (x.name_, f, this),
    style_ (x.style_, f, this),
    id_ (x.id_, f, this),
    type_ (x.type_, f, this),
    default__ (x.default__, f, this),
    required_ (x.required_, f, this),
    repeating_ (x.repeating_, f, this),
    fixed_ (x.fixed_, f, this),
    path_ (x.path_, f, this)
  {
  }

  param::
  param (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    option_ (this),
    link_ (this),
    href_ (this),
    name_ (this),
    style_ (this),
    id_ (this),
    type_ (this),
    default__ (this),
    required_ (this),
    repeating_ (this),
    fixed_ (this),
    path_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void param::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      // option
      //
      if (n.name () == "option" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< option_type > r (
          option_traits::create (i, f, this));

        this->option_.push_back (::std::move (r));
        continue;
      }

      // link
      //
      if (n.name () == "link" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< link_type > r (
          link_traits::create (i, f, this));

        if (!this->link_)
        {
          this->link_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        this->href_.set (href_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "style" && n.namespace_ ().empty ())
      {
        this->style_.set (style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default" && n.namespace_ ().empty ())
      {
        this->default__.set (default_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "required" && n.namespace_ ().empty ())
      {
        this->required_.set (required_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "repeating" && n.namespace_ ().empty ())
      {
        this->repeating_.set (repeating_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fixed" && n.namespace_ ().empty ())
      {
        this->fixed_.set (fixed_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "path" && n.namespace_ ().empty ())
      {
        this->path_.set (path_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (getTypeDefaultValue ());
    }

    if (!required_.present ())
    {
      this->required_.set (getRequiredDefaultValue ());
    }

    if (!repeating_.present ())
    {
      this->repeating_.set (getRepeatingDefaultValue ());
    }
  }

  param* param::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class param (*this, f, c);
  }

  param& param::
  operator= (const param& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->option_ = x.option_;
      this->link_ = x.link_;
      this->href_ = x.href_;
      this->name_ = x.name_;
      this->style_ = x.style_;
      this->id_ = x.id_;
      this->type_ = x.type_;
      this->default__ = x.default__;
      this->required_ = x.required_;
      this->repeating_ = x.repeating_;
      this->fixed_ = x.fixed_;
      this->path_ = x.path_;
    }

    return *this;
  }

  param::
  ~param ()
  {
  }

  // option
  //

  option::
  option (const value_type& value)
  : ::xml_schema::type (),
    doc_ (this),
    value_ (value, this),
    mediaType_ (this)
  {
  }

  option::
  option (const option& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    value_ (x.value_, f, this),
    mediaType_ (x.mediaType_, f, this)
  {
  }

  option::
  option (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    value_ (this),
    mediaType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void option::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "mediaType" && n.namespace_ ().empty ())
      {
        this->mediaType_.set (mediaType_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  option* option::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class option (*this, f, c);
  }

  option& option::
  operator= (const option& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->value_ = x.value_;
      this->mediaType_ = x.mediaType_;
    }

    return *this;
  }

  option::
  ~option ()
  {
  }

  // link
  //

  link::
  link ()
  : ::xml_schema::type (),
    doc_ (this),
    resource_type_ (this),
    rel_ (this),
    rev_ (this)
  {
  }

  link::
  link (const link& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    doc_ (x.doc_, f, this),
    resource_type_ (x.resource_type_, f, this),
    rel_ (x.rel_, f, this),
    rev_ (x.rev_, f, this)
  {
  }

  link::
  link (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    doc_ (this),
    resource_type_ (this),
    rel_ (this),
    rev_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void link::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // doc
      //
      if (n.name () == "doc" && n.namespace_ () == "http://wadl.dev.java.net/2009/02")
      {
        ::std::unique_ptr< doc_type > r (
          doc_traits::create (i, f, this));

        this->doc_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "resource_type" && n.namespace_ ().empty ())
      {
        this->resource_type_.set (resource_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rel" && n.namespace_ ().empty ())
      {
        this->rel_.set (rel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rev" && n.namespace_ ().empty ())
      {
        this->rev_.set (rev_traits::create (i, f, this));
        continue;
      }
    }
  }

  link* link::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class link (*this, f, c);
  }

  link& link::
  operator= (const link& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->doc_ = x.doc_;
      this->resource_type_ = x.resource_type_;
      this->rel_ = x.rel_;
      this->rev_ = x.rev_;
    }

    return *this;
  }

  link::
  ~link ()
  {
  }
}

#include <ostream>

namespace wadl
{
  ::std::ostream&
  operator<< (::std::ostream& o, const resource_type_list& i)
  {
    return o << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, char >& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Method& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, HTTPMethods::value i)
  {
    return o << HTTPMethods::_xsd_HTTPMethods_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const HTTPMethods& i)
  {
    return o << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const uriList& i)
  {
    return o << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, char >& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const statusCodeList& i)
  {
    return o << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char >& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, ParamStyle::value i)
  {
    return o << ParamStyle::_xsd_ParamStyle_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ParamStyle& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const application& i)
  {
    for (application::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    if (i.getGrammars ())
    {
      o << ::std::endl << "grammars: " << *i.getGrammars ();
    }

    for (application::resources_const_iterator
         b (i.getResources ().begin ()), e (i.getResources ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "resources: " << *b;
    }

    for (application::resource_type_const_iterator
         b (i.getResource_type ().begin ()), e (i.getResource_type ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "resource_type: " << *b;
    }

    for (application::method_const_iterator
         b (i.getMethod ().begin ()), e (i.getMethod ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "method: " << *b;
    }

    for (application::representation_const_iterator
         b (i.getRepresentation ().begin ()), e (i.getRepresentation ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "representation: " << *b;
    }

    for (application::param_const_iterator
         b (i.getParam ().begin ()), e (i.getParam ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "param: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const doc& i)
  {
    if (i.getTitle ())
    {
      o << ::std::endl << "title: " << *i.getTitle ();
    }

    if (i.getLang ())
    {
      o << ::std::endl << "lang: " << *i.getLang ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const grammars& i)
  {
    for (grammars::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    for (grammars::include_const_iterator
         b (i.getInclude ().begin ()), e (i.getInclude ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "include: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const resources& i)
  {
    for (resources::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    for (resources::resource_const_iterator
         b (i.getResource ().begin ()), e (i.getResource ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "resource: " << *b;
    }

    if (i.getBase ())
    {
      o << ::std::endl << "base: " << *i.getBase ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const resource& i)
  {
    for (resource::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    for (resource::param_const_iterator
         b (i.getParam ().begin ()), e (i.getParam ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "param: " << *b;
    }

    for (resource::method_const_iterator
         b (i.getMethod ().begin ()), e (i.getMethod ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "method: " << *b;
    }

    for (resource::resource1_const_iterator
         b (i.getResource1 ().begin ()), e (i.getResource1 ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "resource: " << *b;
    }

    if (i.getId ())
    {
      o << ::std::endl << "id: " << *i.getId ();
    }

    if (i.getType ())
    {
      o << ::std::endl << "type: " << *i.getType ();
    }

    o << ::std::endl << "queryType: " << i.getQueryType ();
    if (i.getPath ())
    {
      o << ::std::endl << "path: " << *i.getPath ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const resource_type& i)
  {
    for (resource_type::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    for (resource_type::param_const_iterator
         b (i.getParam ().begin ()), e (i.getParam ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "param: " << *b;
    }

    for (resource_type::method_const_iterator
         b (i.getMethod ().begin ()), e (i.getMethod ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "method: " << *b;
    }

    for (resource_type::resource_const_iterator
         b (i.getResource ().begin ()), e (i.getResource ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "resource: " << *b;
    }

    if (i.getId ())
    {
      o << ::std::endl << "id: " << *i.getId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const method& i)
  {
    for (method::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    if (i.getRequest ())
    {
      o << ::std::endl << "request: " << *i.getRequest ();
    }

    for (method::response_const_iterator
         b (i.getResponse ().begin ()), e (i.getResponse ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "response: " << *b;
    }

    if (i.getId ())
    {
      o << ::std::endl << "id: " << *i.getId ();
    }

    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    if (i.getHref ())
    {
      o << ::std::endl << "href: " << *i.getHref ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const include& i)
  {
    for (include::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    if (i.getHref ())
    {
      o << ::std::endl << "href: " << *i.getHref ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const request& i)
  {
    for (request::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    for (request::param_const_iterator
         b (i.getParam ().begin ()), e (i.getParam ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "param: " << *b;
    }

    for (request::representation_const_iterator
         b (i.getRepresentation ().begin ()), e (i.getRepresentation ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "representation: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const response& i)
  {
    for (response::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    for (response::param_const_iterator
         b (i.getParam ().begin ()), e (i.getParam ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "param: " << *b;
    }

    for (response::representation_const_iterator
         b (i.getRepresentation ().begin ()), e (i.getRepresentation ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "representation: " << *b;
    }

    if (i.getStatus ())
    {
      o << ::std::endl << "status: " << *i.getStatus ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const representation& i)
  {
    for (representation::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    for (representation::param_const_iterator
         b (i.getParam ().begin ()), e (i.getParam ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "param: " << *b;
    }

    if (i.getId ())
    {
      o << ::std::endl << "id: " << *i.getId ();
    }

    if (i.getElement ())
    {
      o << ::std::endl << "element: " << *i.getElement ();
    }

    if (i.getMediaType ())
    {
      o << ::std::endl << "mediaType: " << *i.getMediaType ();
    }

    if (i.getHref ())
    {
      o << ::std::endl << "href: " << *i.getHref ();
    }

    if (i.getProfile ())
    {
      o << ::std::endl << "profile: " << *i.getProfile ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const param& i)
  {
    for (param::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    for (param::option_const_iterator
         b (i.getOption ().begin ()), e (i.getOption ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "option: " << *b;
    }

    if (i.getLink ())
    {
      o << ::std::endl << "link: " << *i.getLink ();
    }

    if (i.getHref ())
    {
      o << ::std::endl << "href: " << *i.getHref ();
    }

    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    if (i.getStyle ())
    {
      o << ::std::endl << "style: " << *i.getStyle ();
    }

    if (i.getId ())
    {
      o << ::std::endl << "id: " << *i.getId ();
    }

    o << ::std::endl << "type: " << i.getType ();
    if (i.getDefault ())
    {
      o << ::std::endl << "default: " << *i.getDefault ();
    }

    o << ::std::endl << "required: " << i.getRequired ();
    o << ::std::endl << "repeating: " << i.getRepeating ();
    if (i.getFixed ())
    {
      o << ::std::endl << "fixed: " << *i.getFixed ();
    }

    if (i.getPath ())
    {
      o << ::std::endl << "path: " << *i.getPath ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const option& i)
  {
    for (option::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    o << ::std::endl << "value: " << i.getValue ();
    if (i.getMediaType ())
    {
      o << ::std::endl << "mediaType: " << *i.getMediaType ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const link& i)
  {
    for (link::doc_const_iterator
         b (i.getDoc ().begin ()), e (i.getDoc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "doc: " << *b;
    }

    if (i.getResource_type ())
    {
      o << ::std::endl << "resource_type: " << *i.getResource_type ();
    }

    if (i.getRel ())
    {
      o << ::std::endl << "rel: " << *i.getRel ();
    }

    if (i.getRev ())
    {
      o << ::std::endl << "rev: " << *i.getRev ();
    }

    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace wadl
{
  ::std::unique_ptr< ::wadl::application >
  parseApplication (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::application > (
      ::wadl::parseApplication (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::application > (
      ::wadl::parseApplication (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::application > (
      ::wadl::parseApplication (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseApplication (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseApplication (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseApplication (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseApplication (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseApplication (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseApplication (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::application > (
      ::wadl::parseApplication (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::application > (
      ::wadl::parseApplication (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::application > (
      ::wadl::parseApplication (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::application > (
        ::wadl::parseApplication (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "application" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::application > r (
        ::xsd::cxx::tree::traits< ::wadl::application, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "application",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::application >
  parseApplication (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "application" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::application > r (
        ::xsd::cxx::tree::traits< ::wadl::application, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "application",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::doc > (
      ::wadl::parseDoc (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::doc > (
      ::wadl::parseDoc (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::doc > (
      ::wadl::parseDoc (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseDoc (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseDoc (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseDoc (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseDoc (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseDoc (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseDoc (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::doc > (
      ::wadl::parseDoc (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::doc > (
      ::wadl::parseDoc (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::doc > (
      ::wadl::parseDoc (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::doc > (
        ::wadl::parseDoc (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "doc" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::doc > r (
        ::xsd::cxx::tree::traits< ::wadl::doc, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "doc",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::doc >
  parseDoc (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "doc" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::doc > r (
        ::xsd::cxx::tree::traits< ::wadl::doc, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "doc",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::grammars > (
      ::wadl::parseGrammars (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::grammars > (
      ::wadl::parseGrammars (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::grammars > (
      ::wadl::parseGrammars (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseGrammars (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseGrammars (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseGrammars (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseGrammars (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseGrammars (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseGrammars (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::grammars > (
      ::wadl::parseGrammars (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::grammars > (
      ::wadl::parseGrammars (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::grammars > (
      ::wadl::parseGrammars (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::grammars > (
        ::wadl::parseGrammars (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "grammars" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::grammars > r (
        ::xsd::cxx::tree::traits< ::wadl::grammars, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "grammars",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::grammars >
  parseGrammars (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "grammars" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::grammars > r (
        ::xsd::cxx::tree::traits< ::wadl::grammars, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "grammars",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::resources > (
      ::wadl::parseResources (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resources > (
      ::wadl::parseResources (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resources > (
      ::wadl::parseResources (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResources (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResources (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResources (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResources (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResources (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResources (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::resources > (
      ::wadl::parseResources (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resources > (
      ::wadl::parseResources (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resources > (
      ::wadl::parseResources (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::resources > (
        ::wadl::parseResources (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "resources" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::resources > r (
        ::xsd::cxx::tree::traits< ::wadl::resources, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resources",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::resources >
  parseResources (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "resources" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::resources > r (
        ::xsd::cxx::tree::traits< ::wadl::resources, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resources",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::resource > (
      ::wadl::parseResource (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resource > (
      ::wadl::parseResource (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resource > (
      ::wadl::parseResource (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResource (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResource (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResource (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResource (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResource (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResource (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::resource > (
      ::wadl::parseResource (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resource > (
      ::wadl::parseResource (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resource > (
      ::wadl::parseResource (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::resource > (
        ::wadl::parseResource (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "resource" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::resource > r (
        ::xsd::cxx::tree::traits< ::wadl::resource, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resource",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::resource >
  parseResource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "resource" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::resource > r (
        ::xsd::cxx::tree::traits< ::wadl::resource, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resource",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::resource_type > (
      ::wadl::parseResource_type (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resource_type > (
      ::wadl::parseResource_type (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resource_type > (
      ::wadl::parseResource_type (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResource_type (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResource_type (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResource_type (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResource_type (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResource_type (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResource_type (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::resource_type > (
      ::wadl::parseResource_type (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resource_type > (
      ::wadl::parseResource_type (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::resource_type > (
      ::wadl::parseResource_type (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::resource_type > (
        ::wadl::parseResource_type (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "resource_type" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::resource_type > r (
        ::xsd::cxx::tree::traits< ::wadl::resource_type, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resource_type",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::resource_type >
  parseResource_type (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "resource_type" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::resource_type > r (
        ::xsd::cxx::tree::traits< ::wadl::resource_type, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "resource_type",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::method > (
      ::wadl::parseMethod (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::method > (
      ::wadl::parseMethod (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::method > (
      ::wadl::parseMethod (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseMethod (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseMethod (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseMethod (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseMethod (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseMethod (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseMethod (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::method > (
      ::wadl::parseMethod (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::method > (
      ::wadl::parseMethod (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::method > (
      ::wadl::parseMethod (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::method > (
        ::wadl::parseMethod (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "method" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::method > r (
        ::xsd::cxx::tree::traits< ::wadl::method, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "method",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::method >
  parseMethod (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "method" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::method > r (
        ::xsd::cxx::tree::traits< ::wadl::method, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "method",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::include > (
      ::wadl::parseInclude (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::include > (
      ::wadl::parseInclude (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::include > (
      ::wadl::parseInclude (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseInclude (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseInclude (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseInclude (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseInclude (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseInclude (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseInclude (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::include > (
      ::wadl::parseInclude (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::include > (
      ::wadl::parseInclude (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::include > (
      ::wadl::parseInclude (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::include > (
        ::wadl::parseInclude (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "include" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::include > r (
        ::xsd::cxx::tree::traits< ::wadl::include, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "include",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::include >
  parseInclude (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "include" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::include > r (
        ::xsd::cxx::tree::traits< ::wadl::include, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "include",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::request > (
      ::wadl::parseRequest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::request > (
      ::wadl::parseRequest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::request > (
      ::wadl::parseRequest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseRequest (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseRequest (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseRequest (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseRequest (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseRequest (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseRequest (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::request > (
      ::wadl::parseRequest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::request > (
      ::wadl::parseRequest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::request > (
      ::wadl::parseRequest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::request > (
        ::wadl::parseRequest (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "request" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::request > r (
        ::xsd::cxx::tree::traits< ::wadl::request, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "request",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::request >
  parseRequest (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "request" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::request > r (
        ::xsd::cxx::tree::traits< ::wadl::request, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "request",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::response > (
      ::wadl::parseResponse (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::response > (
      ::wadl::parseResponse (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::response > (
      ::wadl::parseResponse (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResponse (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResponse (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseResponse (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResponse (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResponse (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseResponse (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::response > (
      ::wadl::parseResponse (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::response > (
      ::wadl::parseResponse (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::response > (
      ::wadl::parseResponse (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::response > (
        ::wadl::parseResponse (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "response" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::response > r (
        ::xsd::cxx::tree::traits< ::wadl::response, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "response",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::response >
  parseResponse (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "response" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::response > r (
        ::xsd::cxx::tree::traits< ::wadl::response, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "response",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::representation > (
      ::wadl::parseRepresentation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::representation > (
      ::wadl::parseRepresentation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::representation > (
      ::wadl::parseRepresentation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseRepresentation (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseRepresentation (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseRepresentation (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseRepresentation (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseRepresentation (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseRepresentation (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::representation > (
      ::wadl::parseRepresentation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::representation > (
      ::wadl::parseRepresentation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::representation > (
      ::wadl::parseRepresentation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::representation > (
        ::wadl::parseRepresentation (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "representation" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::representation > r (
        ::xsd::cxx::tree::traits< ::wadl::representation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "representation",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::representation >
  parseRepresentation (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "representation" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::representation > r (
        ::xsd::cxx::tree::traits< ::wadl::representation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "representation",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::param > (
      ::wadl::parseParam (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::param > (
      ::wadl::parseParam (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::param > (
      ::wadl::parseParam (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseParam (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseParam (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseParam (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseParam (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseParam (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseParam (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::param > (
      ::wadl::parseParam (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::param > (
      ::wadl::parseParam (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::param > (
      ::wadl::parseParam (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::param > (
        ::wadl::parseParam (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "param" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::param > r (
        ::xsd::cxx::tree::traits< ::wadl::param, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "param",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::param >
  parseParam (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "param" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::param > r (
        ::xsd::cxx::tree::traits< ::wadl::param, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "param",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::option > (
      ::wadl::parseOption (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::option > (
      ::wadl::parseOption (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::option > (
      ::wadl::parseOption (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseOption (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseOption (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseOption (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseOption (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseOption (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseOption (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::option > (
      ::wadl::parseOption (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::option > (
      ::wadl::parseOption (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::option > (
      ::wadl::parseOption (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::option > (
        ::wadl::parseOption (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "option" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::option > r (
        ::xsd::cxx::tree::traits< ::wadl::option, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "option",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::option >
  parseOption (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "option" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::option > r (
        ::xsd::cxx::tree::traits< ::wadl::option, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "option",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::link > (
      ::wadl::parseLink (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::link > (
      ::wadl::parseLink (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::link > (
      ::wadl::parseLink (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseLink (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseLink (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::wadl::parseLink (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseLink (isrc, f, p);
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseLink (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::wadl::parseLink (isrc, h, f, p);
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::wadl::link > (
      ::wadl::parseLink (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::link > (
      ::wadl::parseLink (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::wadl::link > (
      ::wadl::parseLink (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::wadl::link > (
        ::wadl::parseLink (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "link" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::link > r (
        ::xsd::cxx::tree::traits< ::wadl::link, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "link",
      "http://wadl.dev.java.net/2009/02");
  }

  ::std::unique_ptr< ::wadl::link >
  parseLink (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "link" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      ::std::unique_ptr< ::wadl::link > r (
        ::xsd::cxx::tree::traits< ::wadl::link, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "link",
      "http://wadl.dev.java.net/2009/02");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace wadl
{
  void
  serializeApplication (::std::ostream& o,
                        const ::wadl::application& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeApplication (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeApplication (::std::ostream& o,
                        const ::wadl::application& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeApplication (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeApplication (::std::ostream& o,
                        const ::wadl::application& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeApplication (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeApplication (::xercesc::XMLFormatTarget& t,
                        const ::wadl::application& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeApplication (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeApplication (::xercesc::XMLFormatTarget& t,
                        const ::wadl::application& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeApplication (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeApplication (::xercesc::XMLFormatTarget& t,
                        const ::wadl::application& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeApplication (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeApplication (::xercesc::DOMDocument& d,
                        const ::wadl::application& s,
                        ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "application" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "application",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeApplication (const ::wadl::application& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "application",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeApplication (*d, s, f);
    return d;
  }

  void
  serializeDoc (::std::ostream& o,
                const ::wadl::doc& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeDoc (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeDoc (::std::ostream& o,
                const ::wadl::doc& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeDoc (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDoc (::std::ostream& o,
                const ::wadl::doc& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeDoc (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDoc (::xercesc::XMLFormatTarget& t,
                const ::wadl::doc& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeDoc (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeDoc (::xercesc::XMLFormatTarget& t,
                const ::wadl::doc& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeDoc (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDoc (::xercesc::XMLFormatTarget& t,
                const ::wadl::doc& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeDoc (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDoc (::xercesc::DOMDocument& d,
                const ::wadl::doc& s,
                ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "doc" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "doc",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeDoc (const ::wadl::doc& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "doc",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeDoc (*d, s, f);
    return d;
  }

  void
  serializeGrammars (::std::ostream& o,
                     const ::wadl::grammars& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeGrammars (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeGrammars (::std::ostream& o,
                     const ::wadl::grammars& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeGrammars (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeGrammars (::std::ostream& o,
                     const ::wadl::grammars& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeGrammars (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeGrammars (::xercesc::XMLFormatTarget& t,
                     const ::wadl::grammars& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeGrammars (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeGrammars (::xercesc::XMLFormatTarget& t,
                     const ::wadl::grammars& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeGrammars (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeGrammars (::xercesc::XMLFormatTarget& t,
                     const ::wadl::grammars& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeGrammars (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeGrammars (::xercesc::DOMDocument& d,
                     const ::wadl::grammars& s,
                     ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "grammars" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "grammars",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeGrammars (const ::wadl::grammars& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "grammars",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeGrammars (*d, s, f);
    return d;
  }

  void
  serializeResources (::std::ostream& o,
                      const ::wadl::resources& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResources (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResources (::std::ostream& o,
                      const ::wadl::resources& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResources (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResources (::std::ostream& o,
                      const ::wadl::resources& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResources (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResources (::xercesc::XMLFormatTarget& t,
                      const ::wadl::resources& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResources (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResources (::xercesc::XMLFormatTarget& t,
                      const ::wadl::resources& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResources (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResources (::xercesc::XMLFormatTarget& t,
                      const ::wadl::resources& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResources (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResources (::xercesc::DOMDocument& d,
                      const ::wadl::resources& s,
                      ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "resources" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "resources",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeResources (const ::wadl::resources& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "resources",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeResources (*d, s, f);
    return d;
  }

  void
  serializeResource (::std::ostream& o,
                     const ::wadl::resource& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResource (::std::ostream& o,
                     const ::wadl::resource& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResource (::std::ostream& o,
                     const ::wadl::resource& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResource (::xercesc::XMLFormatTarget& t,
                     const ::wadl::resource& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResource (::xercesc::XMLFormatTarget& t,
                     const ::wadl::resource& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResource (::xercesc::XMLFormatTarget& t,
                     const ::wadl::resource& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResource (::xercesc::DOMDocument& d,
                     const ::wadl::resource& s,
                     ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "resource" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "resource",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeResource (const ::wadl::resource& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "resource",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeResource (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const resource_type_list& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const resource_type_list& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const resource_type_list& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, char >& > (i);
  }

  void
  serializeResource_type (::std::ostream& o,
                          const ::wadl::resource_type& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource_type (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResource_type (::std::ostream& o,
                          const ::wadl::resource_type& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource_type (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResource_type (::std::ostream& o,
                          const ::wadl::resource_type& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource_type (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResource_type (::xercesc::XMLFormatTarget& t,
                          const ::wadl::resource_type& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource_type (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResource_type (::xercesc::XMLFormatTarget& t,
                          const ::wadl::resource_type& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource_type (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResource_type (::xercesc::XMLFormatTarget& t,
                          const ::wadl::resource_type& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResource_type (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResource_type (::xercesc::DOMDocument& d,
                          const ::wadl::resource_type& s,
                          ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "resource_type" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "resource_type",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeResource_type (const ::wadl::resource_type& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "resource_type",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeResource_type (*d, s, f);
    return d;
  }

  void
  serializeMethod (::std::ostream& o,
                   const ::wadl::method& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeMethod (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeMethod (::std::ostream& o,
                   const ::wadl::method& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeMethod (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeMethod (::std::ostream& o,
                   const ::wadl::method& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeMethod (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeMethod (::xercesc::XMLFormatTarget& t,
                   const ::wadl::method& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeMethod (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeMethod (::xercesc::XMLFormatTarget& t,
                   const ::wadl::method& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeMethod (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeMethod (::xercesc::XMLFormatTarget& t,
                   const ::wadl::method& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeMethod (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeMethod (::xercesc::DOMDocument& d,
                   const ::wadl::method& s,
                   ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "method" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "method",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeMethod (const ::wadl::method& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "method",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeMethod (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const Method& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Method& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Method& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const HTTPMethods& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const HTTPMethods& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const HTTPMethods& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  serializeInclude (::std::ostream& o,
                    const ::wadl::include& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeInclude (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeInclude (::std::ostream& o,
                    const ::wadl::include& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeInclude (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeInclude (::std::ostream& o,
                    const ::wadl::include& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeInclude (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeInclude (::xercesc::XMLFormatTarget& t,
                    const ::wadl::include& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeInclude (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeInclude (::xercesc::XMLFormatTarget& t,
                    const ::wadl::include& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeInclude (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeInclude (::xercesc::XMLFormatTarget& t,
                    const ::wadl::include& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeInclude (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeInclude (::xercesc::DOMDocument& d,
                    const ::wadl::include& s,
                    ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "include" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "include",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeInclude (const ::wadl::include& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "include",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeInclude (*d, s, f);
    return d;
  }

  void
  serializeRequest (::std::ostream& o,
                    const ::wadl::request& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRequest (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRequest (::std::ostream& o,
                    const ::wadl::request& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRequest (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRequest (::std::ostream& o,
                    const ::wadl::request& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRequest (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRequest (::xercesc::XMLFormatTarget& t,
                    const ::wadl::request& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRequest (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRequest (::xercesc::XMLFormatTarget& t,
                    const ::wadl::request& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRequest (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRequest (::xercesc::XMLFormatTarget& t,
                    const ::wadl::request& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRequest (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRequest (::xercesc::DOMDocument& d,
                    const ::wadl::request& s,
                    ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "request" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "request",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeRequest (const ::wadl::request& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "request",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeRequest (*d, s, f);
    return d;
  }

  void
  serializeResponse (::std::ostream& o,
                     const ::wadl::response& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResponse (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResponse (::std::ostream& o,
                     const ::wadl::response& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResponse (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResponse (::std::ostream& o,
                     const ::wadl::response& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResponse (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResponse (::xercesc::XMLFormatTarget& t,
                     const ::wadl::response& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResponse (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResponse (::xercesc::XMLFormatTarget& t,
                     const ::wadl::response& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResponse (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResponse (::xercesc::XMLFormatTarget& t,
                     const ::wadl::response& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeResponse (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResponse (::xercesc::DOMDocument& d,
                     const ::wadl::response& s,
                     ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "response" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "response",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeResponse (const ::wadl::response& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "response",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeResponse (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const uriList& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const uriList& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const uriList& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, char >& > (i);
  }

  void
  serializeRepresentation (::std::ostream& o,
                           const ::wadl::representation& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRepresentation (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRepresentation (::std::ostream& o,
                           const ::wadl::representation& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRepresentation (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRepresentation (::std::ostream& o,
                           const ::wadl::representation& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRepresentation (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRepresentation (::xercesc::XMLFormatTarget& t,
                           const ::wadl::representation& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRepresentation (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRepresentation (::xercesc::XMLFormatTarget& t,
                           const ::wadl::representation& s,
                           ::xml_schema::error_handler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRepresentation (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRepresentation (::xercesc::XMLFormatTarget& t,
                           const ::wadl::representation& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::string& e,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeRepresentation (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRepresentation (::xercesc::DOMDocument& d,
                           const ::wadl::representation& s,
                           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "representation" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "representation",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeRepresentation (const ::wadl::representation& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "representation",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeRepresentation (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const statusCodeList& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const statusCodeList& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const statusCodeList& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParamStyle& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ParamStyle& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ParamStyle& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  serializeParam (::std::ostream& o,
                  const ::wadl::param& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeParam (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeParam (::std::ostream& o,
                  const ::wadl::param& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeParam (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeParam (::std::ostream& o,
                  const ::wadl::param& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeParam (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeParam (::xercesc::XMLFormatTarget& t,
                  const ::wadl::param& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeParam (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeParam (::xercesc::XMLFormatTarget& t,
                  const ::wadl::param& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeParam (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeParam (::xercesc::XMLFormatTarget& t,
                  const ::wadl::param& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeParam (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeParam (::xercesc::DOMDocument& d,
                  const ::wadl::param& s,
                  ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "param" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "param",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeParam (const ::wadl::param& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "param",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeParam (*d, s, f);
    return d;
  }

  void
  serializeOption (::std::ostream& o,
                   const ::wadl::option& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeOption (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeOption (::std::ostream& o,
                   const ::wadl::option& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeOption (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeOption (::std::ostream& o,
                   const ::wadl::option& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeOption (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeOption (::xercesc::XMLFormatTarget& t,
                   const ::wadl::option& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeOption (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeOption (::xercesc::XMLFormatTarget& t,
                   const ::wadl::option& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeOption (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeOption (::xercesc::XMLFormatTarget& t,
                   const ::wadl::option& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeOption (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeOption (::xercesc::DOMDocument& d,
                   const ::wadl::option& s,
                   ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "option" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "option",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeOption (const ::wadl::option& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "option",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeOption (*d, s, f);
    return d;
  }

  void
  serializeLink (::std::ostream& o,
                 const ::wadl::link& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeLink (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeLink (::std::ostream& o,
                 const ::wadl::link& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeLink (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeLink (::std::ostream& o,
                 const ::wadl::link& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeLink (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeLink (::xercesc::XMLFormatTarget& t,
                 const ::wadl::link& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeLink (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeLink (::xercesc::XMLFormatTarget& t,
                 const ::wadl::link& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeLink (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeLink (::xercesc::XMLFormatTarget& t,
                 const ::wadl::link& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::wadl::serializeLink (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeLink (::xercesc::DOMDocument& d,
                 const ::wadl::link& s,
                 ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "link" &&
        n.namespace_ () == "http://wadl.dev.java.net/2009/02")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "link",
        "http://wadl.dev.java.net/2009/02");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeLink (const ::wadl::link& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "link",
        "http://wadl.dev.java.net/2009/02",
        m, f));

    ::wadl::serializeLink (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const application& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (application::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // grammars
    //
    if (i.getGrammars ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "grammars",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *i.getGrammars ();
    }

    // resources
    //
    for (application::resources_const_iterator
         b (i.getResources ().begin ()), n (i.getResources ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "resources",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // resource_type
    //
    for (application::resource_type_const_iterator
         b (i.getResource_type ().begin ()), n (i.getResource_type ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "resource_type",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // method
    //
    for (application::method_const_iterator
         b (i.getMethod ().begin ()), n (i.getMethod ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "method",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // representation
    //
    for (application::representation_const_iterator
         b (i.getRepresentation ().begin ()), n (i.getRepresentation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "representation",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // param
    //
    for (application::param_const_iterator
         b (i.getParam ().begin ()), n (i.getParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "param",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const doc& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // title
    //
    if (i.getTitle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "title",
          e));

      a << *i.getTitle ();
    }

    // lang
    //
    if (i.getLang ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "lang",
          "http://www.w3.org/XML/1998/namespace",
          e));

      a << *i.getLang ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const grammars& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (grammars::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // include
    //
    for (grammars::include_const_iterator
         b (i.getInclude ().begin ()), n (i.getInclude ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "include",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const resources& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (resources::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // resource
    //
    for (resources::resource_const_iterator
         b (i.getResource ().begin ()), n (i.getResource ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "resource",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // base
    //
    if (i.getBase ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "base",
          e));

      a << *i.getBase ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const resource& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (resource::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // param
    //
    for (resource::param_const_iterator
         b (i.getParam ().begin ()), n (i.getParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "param",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // method
    //
    for (resource::method_const_iterator
         b (i.getMethod ().begin ()), n (i.getMethod ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "method",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // resource
    //
    for (resource::resource1_const_iterator
         b (i.getResource1 ().begin ()), n (i.getResource1 ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "resource",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }

    // type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.getType ();
    }

    // queryType
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "queryType",
          e));

      a << i.getQueryType ();
    }

    // path
    //
    if (i.getPath ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "path",
          e));

      a << *i.getPath ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const resource_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (resource_type::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // param
    //
    for (resource_type::param_const_iterator
         b (i.getParam ().begin ()), n (i.getParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "param",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // method
    //
    for (resource_type::method_const_iterator
         b (i.getMethod ().begin ()), n (i.getMethod ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "method",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // resource
    //
    for (resource_type::resource_const_iterator
         b (i.getResource ().begin ()), n (i.getResource ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "resource",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const method& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (method::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // request
    //
    if (i.getRequest ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "request",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *i.getRequest ();
    }

    // response
    //
    for (method::response_const_iterator
         b (i.getResponse ().begin ()), n (i.getResponse ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "response",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }

    // href
    //
    if (i.getHref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "href",
          e));

      a << *i.getHref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const include& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (include::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // href
    //
    if (i.getHref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "href",
          e));

      a << *i.getHref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const request& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (request::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // param
    //
    for (request::param_const_iterator
         b (i.getParam ().begin ()), n (i.getParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "param",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // representation
    //
    for (request::representation_const_iterator
         b (i.getRepresentation ().begin ()), n (i.getRepresentation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "representation",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const response& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (response::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // param
    //
    for (response::param_const_iterator
         b (i.getParam ().begin ()), n (i.getParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "param",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // representation
    //
    for (response::representation_const_iterator
         b (i.getRepresentation ().begin ()), n (i.getRepresentation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "representation",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // status
    //
    if (i.getStatus ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "status",
          e));

      a << *i.getStatus ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const representation& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (representation::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // param
    //
    for (representation::param_const_iterator
         b (i.getParam ().begin ()), n (i.getParam ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "param",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }

    // element
    //
    if (i.getElement ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "element",
          e));

      a << *i.getElement ();
    }

    // mediaType
    //
    if (i.getMediaType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mediaType",
          e));

      a << *i.getMediaType ();
    }

    // href
    //
    if (i.getHref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "href",
          e));

      a << *i.getHref ();
    }

    // profile
    //
    if (i.getProfile ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "profile",
          e));

      a << *i.getProfile ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const param& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (param::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // option
    //
    for (param::option_const_iterator
         b (i.getOption ().begin ()), n (i.getOption ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "option",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // link
    //
    if (i.getLink ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "link",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *i.getLink ();
    }

    // href
    //
    if (i.getHref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "href",
          e));

      a << *i.getHref ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }

    // style
    //
    if (i.getStyle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "style",
          e));

      a << *i.getStyle ();
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.getType ();
    }

    // default
    //
    if (i.getDefault ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "default",
          e));

      a << *i.getDefault ();
    }

    // required
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "required",
          e));

      a << i.getRequired ();
    }

    // repeating
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "repeating",
          e));

      a << i.getRepeating ();
    }

    // fixed
    //
    if (i.getFixed ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fixed",
          e));

      a << *i.getFixed ();
    }

    // path
    //
    if (i.getPath ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "path",
          e));

      a << *i.getPath ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const option& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (option::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.getValue ();
    }

    // mediaType
    //
    if (i.getMediaType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mediaType",
          e));

      a << *i.getMediaType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const link& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // doc
    //
    for (link::doc_const_iterator
         b (i.getDoc ().begin ()), n (i.getDoc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "doc",
          "http://wadl.dev.java.net/2009/02",
          e));

      s << *b;
    }

    // resource_type
    //
    if (i.getResource_type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "resource_type",
          e));

      a << *i.getResource_type ();
    }

    // rel
    //
    if (i.getRel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rel",
          e));

      a << *i.getRel ();
    }

    // rev
    //
    if (i.getRev ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rev",
          e));

      a << *i.getRev ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

